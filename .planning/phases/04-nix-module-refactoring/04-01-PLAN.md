---
phase: 04-nix-module-refactoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - modules/home/linux/intune.nix
autonomous: true

must_haves:
  truths:
    - "Single module file handles both x86_64 and Rosetta architectures"
    - "Architecture mode is detected once at module top"
    - "Library paths use category-based groupings"
    - "No duplicate LD_LIBRARY_PATH strings in wrappers"
    - "Module is under 500 lines"
  artifacts:
    - path: "modules/home/linux/intune.nix"
      provides: "Unified Intune module with mode detection"
      min_lines: 300
      max_lines: 500
      contains: "mode ="
  key_links:
    - from: "modules/home/linux/intune.nix"
      to: "pkgsX86"
      via: "conditional import"
      pattern: "isRosetta.*pkgsX86"
---

<objective>
Create the unified intune.nix module with architecture detection and category-based library groupings.

Purpose: Merge intune-rosetta.nix (1048 lines) and intune-nix.nix (668 lines) into a single well-organized module under 500 lines that handles both architectures via mode detection.

Output: New `modules/home/linux/intune.nix` with:
- Mode detection enum (native-x86_64, rosetta)
- Category-based library path groupings
- Unified LD_LIBRARY_PATH variable (no duplication)
- Clean section organization
</objective>

<execution_context>
@/Users/andreym/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andreym/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-nix-module-refactoring/04-CONTEXT.md
@.planning/phases/04-nix-module-refactoring/04-RESEARCH.md
@modules/home/linux/intune-rosetta.nix
@modules/home/linux/intune-nix.nix
@modules/home/linux/rosetta.nix
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unified intune.nix with mode detection and library categories</name>
  <files>modules/home/linux/intune.nix</files>
  <action>
Create new `modules/home/linux/intune.nix` following this structure:

**Header Documentation Block:**
- Module purpose: Microsoft Intune on Linux (both x86_64 native and aarch64/Rosetta)
- Mode detection explanation
- Dependencies (rosetta.nix for Rosetta mode)
- Caveats (OpenSSL 3.3.2 workaround, library paths needed for non-NixOS)

**Architecture Detection (first let block):**
```nix
let
  cfg = config.modules.linux.intune;

  # Detect operating mode once at top
  mode =
    if pkgs.stdenv.hostPlatform.isx86_64 then "native-x86_64"
    else if pkgs.stdenv.hostPlatform.isAarch64 && builtins.pathExists "/mnt/psf/RosettaLinux/rosetta"
    then "rosetta"
    else null;

  isRosetta = mode == "rosetta";
  isNativeX86 = mode == "native-x86_64";

  # Package source varies by mode (only import pkgsX86 when needed)
  pkgSource = if isRosetta then pkgsX86 else pkgs;

  # Cross-arch packages (only evaluated in Rosetta mode)
  pkgsX86 = if isRosetta then import pkgs.path {
    system = "x86_64-linux";
    config.allowUnfree = true;
  } else null;
```

**Library Path Categories (with WORKAROUND TODO marker):**
```nix
  # ============================================================================
  # LIBRARY PATHS - WORKAROUND SECTION
  # TODO: Remove entire section when native arm64 Intune packages are available
  # These libraries are needed because x86_64 binaries run on Arch Linux which
  # doesn't have these in standard library paths (non-NixOS).
  # ============================================================================

  glibcLibs = [ "${pkgSource.stdenv.cc.cc.lib}/lib" ];

  systemLibs = map (p: "${p}/lib") [
    pkgSource.dbus.lib
    pkgSource.glib.out
    pkgSource.systemdLibs
    pkgSource.util-linux.lib
    pkgSource.zlib.out
    pkgSource.zstd.out
    pkgSource.icu.out
    pkgSource.expat.out
    pkgSource.pcre2.out
  ];

  # ... (x11Libs, gtkLibs, webkitLibs, tlsLibs, pkcs11Libs, mediaLibs, networkLibs)

  # Compose final library path (used once, referenced by all wrappers)
  fullLibraryPath = lib.concatStringsSep ":" (
    [ opensslArchPath ]  # CRITICAL: OpenSSL 3.3.2 must be first
    ++ glibcLibs
    ++ systemLibs
    ++ x11Libs
    ++ gtkLibs
    ++ webkitLibs
    ++ tlsLibs
    ++ pkcs11Libs
    ++ mediaLibs
    ++ networkLibs
  );
```

**Environment Variable Helpers:**
Keep the existing mesaEnvVars, webkitEnvVars, tlsEnvVars, pkcs11EnvVars, debugEnvVars.

**Wrappers (using fullLibraryPath):**
- intuneWrapper: Uses fullLibraryPath variable (not inline path)
- intuneAgentWrapper: Uses fullLibraryPath variable
- userBrokerWrapper: Uses fullLibraryPath variable
- deviceBrokerWrapper: Uses fullLibraryPath variable

Wrapper suffix logic:
```nix
wrapperSuffix = if isRosetta then "-rosetta" else "";
```

**Helper Scripts:**
Keep logsHelper, statusHelper, pkcs11DiagHelper, nssSetupHelper (trim if over 500 lines).

**Options (grouped at top, before config):**
```nix
options.modules.linux.intune = {
  enable = mkEnableOption "Microsoft Intune Portal with identity brokers";
  debug = mkOption {
    type = types.bool;
    default = false;
    description = "Enable debug logging for all Intune components";
  };
};
```

**Config (with mode check guard):**
```nix
config = mkIf (cfg.enable && pkgs.stdenv.isLinux && mode != null) {
  # Enable Rosetta binfmt support (only for Rosetta mode)
  modules.linux.rosetta.enable = isRosetta;

  home.packages = [ ... ];
  xdg.dataFile = { ... };
  xdg.configFile = { ... };
  systemd.user.services = { ... };
  systemd.user.timers = { ... };
  home.activation = { ... };
};
```

**Line budget:** Target 450-500 lines. Achieve by:
1. Single fullLibraryPath variable instead of 4 duplicates (~100 lines saved)
2. Category-based lib lists with `map` instead of manual paths (~50 lines saved)
3. Remove verbose pkcs11DiagHelper script (move to separate utility if needed)
4. Remove nssSetupHelper (move to separate utility if needed)

**What NOT to change:**
- OpenSSL 3.3.2 workaround stays (it fixes Code:1200)
- OpenSC from Arch archives stays (symbol compatibility)
- D-Bus service file structure
- Systemd service/timer definitions
- Activation script logic
  </action>
  <verify>
Verify module syntax and line count:
```bash
cd /Users/andreym/Documents/dotfiles
nix-instantiate --parse modules/home/linux/intune.nix
wc -l modules/home/linux/intune.nix  # Should be under 500
grep -c "mode =" modules/home/linux/intune.nix  # Should be 1
grep -c "LD_LIBRARY_PATH" modules/home/linux/intune.nix  # Should be 4 (one per wrapper, not 4 inline paths)
```
  </verify>
  <done>
- New intune.nix exists with mode detection at top
- Library paths organized by category
- Single fullLibraryPath variable used by all wrappers
- Module under 500 lines
- Nix syntax valid (nix-instantiate parses successfully)
  </done>
</task>

</tasks>

<verification>
After task completion:
1. `nix-instantiate --parse modules/home/linux/intune.nix` succeeds
2. Module is under 500 lines: `wc -l modules/home/linux/intune.nix`
3. Mode detection exists: `grep "mode =" modules/home/linux/intune.nix`
4. No duplicate inline LD_LIBRARY_PATH: `grep -c "fullLibraryPath" modules/home/linux/intune.nix` shows usage in wrappers
5. Library categories exist: `grep -E "(glibcLibs|systemLibs|x11Libs|gtkLibs)" modules/home/linux/intune.nix`
</verification>

<success_criteria>
- [ ] modules/home/linux/intune.nix created
- [ ] Mode detection (native-x86_64, rosetta) at module top
- [ ] Library paths use category-based groupings
- [ ] Single fullLibraryPath variable (no duplicate path strings)
- [ ] Module under 500 lines
- [ ] Nix syntax valid
</success_criteria>

<output>
After completion, create `.planning/phases/04-nix-module-refactoring/04-01-SUMMARY.md`
</output>
